import secrets
import time
import multiprocessing as mp
import math
import base64
import os
import hashlib

def miller_rabin_normalize(n):
    """
        n - Number to normalize for the miller_rabin algorithm.

        Returns: Represents the number in the form n = 2^k * q, where q is an odd number. First return
                 value is k, the second is q.
    """
    k = 0

    while n & 1 == 0:
        k += 1
        n >>= 1

    return (k, n)

def miller_rabin(n, rounds, stop_event, debug = False):
    '''
        n - Number which primality is being tested.
        rounds - Number of rounds of the algorithm. The worst case probability that a composite number is reported to be
                 prime is (1 / 4)^{rounds}.
        debug - Whether to pring debug logs or not.

        Returns: True if the given number passes the test, False if the number is composite.
    '''
    if debug:
        start = time.time()

    k, q = miller_rabin_normalize(n - 1)
    # candidate_set = set()

    for round in range(rounds):
        if stop_event.is_set():
            return True
        
        a = 2 + secrets.randbelow(n - 2)

        if math.gcd(n, a) > 1:
            return False

        t = pow(a, q, n)

        if t == 1:
            continue

        for _ in range(k):
            if t == n - 1:
                break

            t = pow(t, 2, n)

        else:
            if debug:
                end = time.time()
                print("Miller-Rabin test concluded that the given number is composite.")
                print("Number of rounds: {:d}. Total rounds: {:d}".format(round + 1, rounds))
                print("Time taken for computation: {:f}s\n".format(end - start))
            return False

    if debug:
        end = time.time()
        print("Miller-Rabin test concluded that the given number could be prime.")
        print("Time taken for computation: {:f}s\n".format(end - start))

    stop_event.set()
    return True

def miller_rabin_generator(bits, rounds, stop_event, debug = False):
    """
        bits - Number of bits for the desired prime.
        rounds - Specify maximum number of iterations for each Miller-Rabin test.
        debug - Whether to print debug logs.

        Returns: The generated prime number, number of iterations and time taken.
    """
    start = time.time()
    iterations = 1

    while True:
        p = secrets.randbits(bits)
        # Non-redundant last bit
        p |= (1 << (bits - 1))
        # Ensure we are dealing with an odd number
        p |= 1

        if miller_rabin(p, rounds, stop_event, debug = False):
            break

        iterations += 1

    end = time.time()

    if debug:
        print("Found a probable prime with {:d} bits after {:d} iterations.".format(bits, iterations))
        print("Worst case probability that the chosen number is composite: {:f}".format((1 / 4) ** rounds))
        print("Time taken for computation: {:f}s\n".format(end - start))

    return p, iterations, end - start

def worker(bits, rounds, queue, stop_event):
    """
        bits - Number of bits to pass to the Miller-Rabin generator function.
        rounds - Number of rounds to pass to the Miller-Ragin generator function.
        queue - Multiprocessing queue in which the result should be stored.

        Returns: None. This function is invoked by worker child processes, which invoke the Miller-Rabin
                 generator function in parallel.
    """
    # Ensure that workers are not running in debug mode!
    queue.put(miller_rabin_generator(bits, rounds, stop_event, debug = False))

def miller_rabin_generator_wrapper(bits, rounds, n_processes, debug = False):
    """
        bits - Number of bits for the desired prime number.
        rounds - Number of rounds for each Miller-Rabin test
        n_processes - Number of child processes which will be created to invoke miller_rabin_generator
        debug - Whether to print debug logs.

        Returns: Prime number generated by one of the child processes. The rest of child processes are terminated
                 once one finds a prime number.
    """
    queue = mp.Queue()
    stop_event = mp.Event()
    
    processes = []

    for _ in range(n_processes):
        p = mp.Process(target = worker, args = (bits, rounds, queue, stop_event))
        processes.append(p)
        p.start()

    # Queue.get is blocking the caller process untill the queue gets filled by another process
    # We are waiting for the first child process to find a prime number.
    prime, iterations, t = queue.get()
    
    for p in processes:
        p.join()
        p.close()
        
    if debug:
        print("Found a probable prime with {:d} bits after {:d} iterations.".format(bits, iterations))
        print("Worst case probability that the chosen number is composite: {:f}".format((1 / 4) ** rounds))
        print("Time taken for computation: {:f}s".format(t))
        print("Found prime: {:d}\n".format(prime))
    
    results = {
        "prime": prime,
        "worst_case_probability": (1 / 4) ** rounds,
        "time_taken_seconds": t,
        "iterations": iterations
    }
    
    return results